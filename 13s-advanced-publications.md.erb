---
title: Publicaciones avanzadas
slug: advanced-publications
date: 0013/01/02
number: 13.5
sidebar: true
contents: Aprenderemos patrones más avanzados para manipular publicaciones.|Veremos lo flexibles que son publicaciones y suscripciones. 
paragraphs: 36
---

A esta altura ya deberías tener una buena base de cómo interactúan las suscripciones y las publicaciones. Así que vamos a deshacernos de las ruedas de entrenamiento y examinar unos escenarios más avanzados.
 
### Publicar una Colección Varias Veces

En [nuestras primeras publicaciones en sidebar](/chapter/publications-and-subscriptions/), vimos algunas de los patrones más comunes de publicación y suscripción, y aprendimos cómo la función `_publishCursor` hizo muy fácil implementarlos en nuestros propios sitios.

Primero, vamos a recapitular exactamente qué hace por nosotros la función `_publishCursor`: toma todos los documentos que concuerdan con un cursor dado, y los envía a la colección del cliente *del mismo nombre*. Nótese que el nombre de la _publicación_ no está involucrado.

Esto significa que podemos tener _más de una publicación_ de cualquier colección, que enlaza al cliente y al servidor

Ya hemos encontrado este patrón en nuestro [capítulo de paginación](/chapter/pagination/), cuando publicamos un subconjunto paginado de todos los posts, además del post actual.

Otro caso de uso similar es publicar una *overview* de un largo conjunto de documentos, así como también los detalles completos de un simple ítem:
 
<%= diagram "doublecollection", "Publishing a collection twice", "pull-center" %>

~~~js
Meteor.publish('allPosts', function() {
  return Posts.find({}, {fields: {title: true, author: true}});
});

Meteor.publish('postDetail', function(postId) {
  return Posts.find(postId);
});
~~~

Ahora, cuando el cliente se suscribe a estas dos publicaciones (utilizando `autorun` para asegurar que el `postId` está siendo enviado a la suscripción `postDetail`), su colección `'posts'` es completada a partir de dos fuentes: una lista de los títulos y los nombres de los autores de la primera suscripción, y todos los detalles del segundo post.
 
Como pueden darse cuenta, el post publicado por `postDetail` también lo está siendo por `allPosts` ( aunque con sólo un subconjunto de sus propiedades ). Sin embargo, Meteor se encarga de la superposición mediante la fusión de los campos y asegurando que no existen duplicados.
 
Esto es genial, porque ahora cuando renderizamos la lista de posts, estamos lidiando con objetos de datos que tienen apenas suficiente informacion para mostrar. Sin embargo, cuando renderizamos la página para un solo post, tenemos todo lo que necesitamos mostrar. Por supuesto, tenemos que tener cuidado en el cliente para no esperar que todos los campos estén disponibles en todos los posts -- esto es una fuente común de problemas!
 
Debe tenerse en cuenta que no estás limitado a variar las propiedades del documento. Podrías perfectamente publicar las mismas propiedades en ambas publicaciones, pero ordenar los items de otra manera.
 
~~~js
Meteor.publish('newPosts', function(limit) {
  return Posts.find({}, {sort: {submitted: -1}, limit: limit});
});

Meteor.publish('bestPosts', function(limit) {
  return Posts.find({}, {sort: {votes: -1, submitted: -1}, limit: limit});
});
~~~
<%= caption "server/publications.js" %>

### Subscribing to a Publication Multiple Times

////
 
////
 
////
 
<%= diagram "subscribetwice", "Subscribing twice to one publication", "pull-center" %>

////
 
~~~js
Meteor.publish('posts', function(options) {
  return Posts.find({}, options);
});
~~~

////
 
~~~js
Meteor.subscribe('posts', {submitted: -1, limit: 10});
Meteor.subscribe('posts', {baseScore: -1, submitted: -1, limit: 10});
~~~

////
 
////
 
### Multiple Collections in a Single Subscription

////
 
////
 
////
 
////
 
////
 
////
 
////
 
<%= diagram "multiplecollections", "Two collections in one subscription", "pull-center" %>

~~~js
Meteor.publish('topComments', function(topPostIds) {
  return Comments.find({postId: topPostIds});
});
~~~

////
 
////
 
~~~js
Meteor.publish('topPosts', function(limit) {
  var sub = this, commentHandles = [], postHandle = null;
  
  // send over the top two comments attached to a single post
  function publishPostComments(postId) {
    var commentsCursor = Comments.find({postId: postId}, {limit: 2});
    commentHandles[post._id] = 
      Meteor.Collection._publishCursor(commentsCursor, sub, 'comments');
  }
    
  postHandle = Posts.find({}, {limit: limit}).observeChanges({
    added: function(id, post) {
      publishPostComments(post._id);
      sub.added('posts', id, post);
    },
    changed: function(id, fields) {
      sub.changed('posts', id, fields);
    },
    removed: function(id) {
      // stop observing changes on the post's comments
      commentHandles[id] && commentHandles[id].stop();
      // delete the post
      sub.removed('posts', id);
    }
  });
  
  sub.ready();
  
  // make sure we clean everything up (note `_publishCursor`
  //   does this for us with the comment observers)
  sub.onStop(function() { postsHandle.stop(); });
});
~~~

////
 
////
 
////
 
### Linking different collections

////
 
<%= diagram "linkedcollections", "One collection for two subscriptions", "pull-center" %>

////
 
////
 
////
 
////
 
~~~js
  Meteor.publish('videos', function() {
    var sub = this;
    
    var videosCursor = Resources.find({type: 'video'});
    Meteor.Collection._publishCursor(videosCursor, sub, 'videos');
    
    // _publishCursor doesn't call this for us in case we do this more than once.
    sub.ready();
  });
~~~

////
 
////
 
